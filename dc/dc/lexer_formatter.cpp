//
//  smcpp.ds.cpp
//  dc
//
//  Created by David Lindeque on 30/01/2016.
//  Copyright Â© 2016 David Lindeque. All rights reserved.
//

#include "lexer_formatter.h"
#include "log.h"
#include "logger.h"
#include "container.h"
#include "cpp_helpers.h"
#include "helpers.h"

#include <map>
#include <fstream>

namespace dc
{
    auto output_lexer_cpp::write_h(DocumentAstProcessor &processor, const symbolreference &ns, const spantext &lexer_name) const -> bool 
    {
        std::string fn = get_standard_output_filename(_compile_filename, _path, ".lexer.h");
        log::info::WritingOutputFile(_logger, fn);
        std::wofstream hstm(fn);
        if (!hstm) {
            log::error::FailureOpeningFile(_logger, std::shared_ptr<container>(), span(), fn);
            return false;
        }
        std::string model_hfn = get_relative_filename(fn, get_standard_output_filename(_compile_filename, _path, ".model.h"));


        hstm << L"// Generated by Dave Compiler" << std::endl << std::endl;
        hstm << L"#pragma once" << std::endl << std::endl;
        hstm << L"#include <iostream>" << std::endl;
        hstm << L"#include <string>" << std::endl;
        hstm << L"#include <vector>" << std::endl;
        hstm << L"#include \"" << std::wstring(model_hfn.begin(), model_hfn.end()) << L"\"" << std::endl;
        hstm << std::endl;
        hstm << L"namespace " << ns << L" {" << std::endl;
        hstm << L"    class " << lexer_name << L" {" << std::endl;
        hstm << L"    private:" << std::endl;
        hstm << L"        // state of the lexer" << std::endl;
        hstm << L"        long _line;" << std::endl;
        hstm << L"        long _column;" << std::endl;
        hstm << L"        std::wistream &_stm;" << std::endl;
        hstm << L"        wchar_t _ch;" << std::endl;
        hstm << L"        std::vector<size_t> _states;" << std::endl;
        hstm << L"    public:" << std::endl;
        hstm << L"        " << lexer_name << L"() = delete;" << std::endl;
        hstm << L"        " << lexer_name << L"(const " << lexer_name << L"&) = delete;" << std::endl;
        hstm << L"        " << lexer_name << L"(" << lexer_name << L"&&) = delete;" << std::endl;
        hstm << L"        " << lexer_name << L"(std::wistream &stm)" << std::endl;
        hstm << L"        : _stm(stm), _line(1), _column(1)" << std::endl;
        hstm << L"        {" << std::endl;
        hstm << L"            // Read the first char" << std::endl;
        hstm << L"            _ch = _stm.get();" << std::endl;
        hstm << L"            // Initialize the states" << std::endl;
        hstm << L"            _states.push_back(0);" << std::endl;
        hstm << L"        }" << std::endl;
        hstm << std::endl;
        hstm << L"        inline auto operator=(const " << lexer_name << L" &) -> " << lexer_name << L"& = delete;" << std::endl;
        hstm << L"        inline auto operator=(" << lexer_name << L" &&c) -> " << lexer_name << L"& = delete;" << std::endl;
        hstm << std::endl;
        hstm << L"        // state of the lexer" << std::endl;
        hstm << L"        inline auto line() const -> const long& { return _line; }" << std::endl;
        hstm << L"        inline auto line() -> long& { return _line; }" << std::endl;
        hstm << L"        inline auto column() const -> const long& { return _column; }" << std::endl;
        hstm << L"        inline auto column() -> long& { return _column; }" << std::endl;
        hstm << L"        inline auto stm() const -> const std::wistream& { return _stm; }" << std::endl;
        hstm << L"        inline auto stm() -> std::wistream& { return _stm; }" << std::endl;
        hstm << L"        inline auto states() const -> const std::vector<size_t>& { return _states; }" << std::endl;
        hstm << L"        inline auto states() -> std::vector<size_t>& { return _states; }" << std::endl;
        hstm << L"" << std::endl;
        hstm << L"        auto try_read_next_token(long &start_line, long &start_column, long &end_line, long &end_column, std::wstring &value, " << to_cpp_symbol(get_nsitem_symbol_reference(processor.automata_match_return_type())) << L" &token) -> bool;" << std::endl;
        hstm << L"    };" << std::endl;
        hstm << L"}" << std::endl;

        return true;
    }

    inline auto write_position_advance(std::wostream &stm, const std::wstring &prefix, wchar_t can_be_from, wchar_t can_be_to) -> void {
        if (can_be_from == can_be_to) {
            // Single char
            switch(can_be_from) {
            case L'\n':
                stm << prefix << L"_line++;" << std::endl << prefix << L"_column = 1;" << std::endl;
                break;
            case L'\r':
                stm << prefix << L"_column = 1;" << std::endl;
                break;
            default:
                stm << prefix << L"_column++;" << std::endl;
                break;
            }
        } else {
            // Will never 'contain' the position alterators
            assert(can_be_from > L'\n' || can_be_to < L'\n');
            assert(can_be_from > L'\r' || can_be_to < L'\r');
            stm << prefix << L"_column++;" << std::endl;
        }
    }
    
    inline auto write_if_body(DocumentAstProcessor &processor, const symbolreference &ns, std::wofstream &cppstm, const Transition* transition, wchar_t char_range_from, wchar_t char_range_to) -> void
    {
        if (processor.dfa().transitions.find(transition->ToState) == processor.dfa().transitions.end()) {
            // We've got no transitions out of the ToState - we can just return the action
            auto a2 = processor.dfa().actions.find(transition->ToState);
            assert(a2 != processor.dfa().actions.end());
            cppstm << L"                        token = " << ns << L"::" << to_cpp_symbol(a2->second.YieldAction.TokenName) << L';' << std::endl;
            if (a2->second.YieldAction.IsGoto) {
                cppstm << L"                        _states.push_back(" << a2->second.YieldAction.GotoAutomata << L");" << std::endl;
            } 
            else if (a2->second.YieldAction.IsReturn) {
                cppstm << L"                        _states.pop_back();" << std::endl;
            }
            cppstm << L"                        value += _ch;" << std::endl;
            write_position_advance(cppstm, L"                        ", char_range_from, char_range_to);
            cppstm << L"                        end_line = _line;" << std::endl;
            cppstm << L"                        end_column = _column;" << std::endl;
            cppstm << L"                        _ch = _stm.get();" << std::endl;
            cppstm << L"                        return true;" << std::endl;
        }
        else {
            cppstm << L"                        s = " << transition->ToState << L';' << std::endl;
            write_position_advance(cppstm, L"                        ", char_range_from, char_range_to);
        }
    }

    auto output_lexer_cpp::write_cpp(DocumentAstProcessor &processor, const symbolreference &ns, const spantext &lexer_name) const -> bool
    {
        std::string fn = get_standard_output_filename(_compile_filename, _path, ".lexer.cpp");
        log::info::WritingOutputFile(_logger, fn);
        std::wofstream cppstm(fn);
        if (!cppstm) {
            log::error::FailureOpeningFile(_logger, std::shared_ptr<container>(), span(), fn);
            return false;
        }
        std::string hfn = get_relative_filename(fn, get_standard_output_filename(_compile_filename, _path, ".lexer.h"));

        cppstm << L"// Generated by Dave Compiler" << std::endl << std::endl;
        cppstm << L"#include \"" << std::wstring(hfn.begin(), hfn.end()) << L"\"" << std::endl;
        cppstm << L"#include <iostream>" << std::endl;
        cppstm << L"#include <string>" << std::endl;
        cppstm << L"#include <assert.h>" << std::endl;
        cppstm << std::endl;
        cppstm << L"namespace " << ns << L" {" << std::endl;
        cppstm << L"    auto " << lexer_name << L"::try_read_next_token(long &start_line, long &start_column, long &end_line, long &end_column, std::wstring &value, " << to_cpp_symbol(get_nsitem_symbol_reference(processor.automata_match_return_type())) << L" &token) -> bool" << std::endl;
        cppstm << L"    {" << std::endl;
        cppstm << L"        start_line = _line;" << std::endl;
        cppstm << L"        start_column = _column;" << std::endl;
        cppstm << L"        size_t s = _states.back();" << std::endl;
        cppstm << L"        value.clear();" << std::endl;
        cppstm << L"        while(true) {" << std::endl;
        cppstm << L"            if (_ch == std::char_traits<wchar_t>::eof()) {" << std::endl;
        cppstm << L"                end_line = _line;" << std::endl;
        cppstm << L"                end_column = _column;" << std::endl;
        cppstm << L"                return false;" << std::endl;
        cppstm << L"            }" << std::endl;
        cppstm << L"            switch(s) {" << std::endl;
        for(auto &s : processor.dfa().transitions) {
            cppstm << L"            case " << s.first << L':' << std::endl;

            auto action = processor.dfa().actions.find(s.first);

            cppstm << L"                switch(_ch) {" << std::endl;
            std::vector<const Transition*> ct;
            for(auto &t : s.second) {
                if (t.First == t.Last) {
                    cppstm << L"                case " << (int)t.First << L": // " << cpp_comment(log::printable(t.First)) << std::endl;
                    if (processor.dfa().transitions.find(t.ToState) == processor.dfa().transitions.end()) {
                        // We've got no transitions out of the ToState - we can just return the action
                        auto a2 = processor.dfa().actions.find(t.ToState);
                        assert(a2 != processor.dfa().actions.end());
                        cppstm << L"                    token = " << ns << L"::" << to_cpp_symbol(a2->second.YieldAction.TokenName) << L';' << std::endl;
                        if (a2->second.YieldAction.IsGoto) {
                            cppstm << L"                    _states.push_back(" << a2->second.YieldAction.GotoAutomata << L");" << std::endl;
                        } 
                        else if (a2->second.YieldAction.IsReturn) {
                            cppstm << L"                    _states.pop_back();" << std::endl;
                        }
                        cppstm << L"                    value += _ch;" << std::endl;
                        write_position_advance(cppstm, L"                    ", t.First, t.Last);
                        cppstm << L"                    end_line = _line;" << std::endl;
                        cppstm << L"                    end_column = _column;" << std::endl;
                        cppstm << L"                    _ch = _stm.get();" << std::endl;
                        cppstm << L"                    return true;" << std::endl;
                    }
                    else {
                        // We can carry on to that state. If the ToState doesn't have any outbound transitions then we yield what it yields
                        cppstm << L"                    s = " << t.ToState << L';' << std::endl;
                        write_position_advance(cppstm, L"                    ", t.First, t.Last);
                        cppstm << L"                    break;" << std::endl;
                    }
                }
                else {
                    ct.push_back(&t);
                }
            }
            
            if (!ct.empty() || action != processor.dfa().actions.end()) {
                cppstm << L"                default:" << std::endl;
                if (!ct.empty()) {
                    cppstm << L"                    if (_ch >= " << (int)ct[0]->First << " && _ch <= " << (int)ct[0]->Last << ") { // " << cpp_comment(log::printable(ct[0]->First)) << L" - " << cpp_comment(log::printable(ct[0]->Last)) << std::endl;
                    write_if_body(processor, ns, cppstm, ct[0], ct[0]->First, ct[0]->Last);
                    for(size_t i = 1; i < ct.size(); i++) {
                        cppstm << L"                    } else if (_ch >= " << (int)ct[i]->First << " && _ch <= " << (int)ct[i]->Last << ") { // " << cpp_comment(log::printable(ct[i]->First)) << L" - " << cpp_comment(log::printable(ct[i]->Last)) << std::endl;
                        write_if_body(processor, ns, cppstm, ct[i], ct[i]->First, ct[i]->Last);
                    }
                    cppstm << L"                    }" << std::endl;
                    if (action != processor.dfa().actions.end()) {
                        cppstm << L"                    else {" << std::endl;
                        cppstm << L"                        // Yield" << std::endl;
                        cppstm << L"                        end_line = _line;" << std::endl;
                        cppstm << L"                        end_column = _column;" << std::endl;
                        cppstm << L"                        token = " << ns << L"::" << to_cpp_symbol(action->second.YieldAction.TokenName) << L';' << std::endl;
                        if (action->second.YieldAction.IsGoto) {
                            cppstm << L"                        _states.push_back(" << action->second.YieldAction.GotoAutomata << L");" << std::endl;
                        } 
                        else if (action->second.YieldAction.IsReturn) {
                            cppstm << L"                        _states.pop_back();" << std::endl;
                        }
                        cppstm << L"                        return true;" << std::endl;
                        cppstm << L"                    }" << std::endl;
                    }
                }
                else if (action != processor.dfa().actions.end()) {
                    cppstm << L"                    // Yield" << std::endl;
                    cppstm << L"                    end_line = _line;" << std::endl;
                    cppstm << L"                    end_column = _column;" << std::endl;
                    cppstm << L"                    token = " << ns << L"::" << to_cpp_symbol(action->second.YieldAction.TokenName) << L';' << std::endl;
                    if (action->second.YieldAction.IsGoto) {
                        cppstm << L"                    _states.push_back(" << action->second.YieldAction.GotoAutomata << L");" << std::endl;
                    } 
                    else if (action->second.YieldAction.IsReturn) {
                        cppstm << L"                    _states.pop_back();" << std::endl;
                    }
                    cppstm << L"                    return true;" << std::endl;
                }
                else {
                    cppstm << L"                    break;" << std::endl;
                }
            }
            
            cppstm << L"                }" << std::endl;
            cppstm << L"                break;" << std::endl;
        }
        cppstm << L"            }" << std::endl;
        cppstm << L"            value += _ch;" << std::endl;
        cppstm << L"            _ch = _stm.get();" << std::endl;
        cppstm << L"        }" << std::endl;
        cppstm << L"    }" << std::endl;
        cppstm << L"}" << std::endl;
        
        return true;
    }
}
