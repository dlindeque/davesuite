//
//  smcpp.ds.cpp
//  dc
//
//  Created by David Lindeque on 30/01/2016.
//  Copyright Â© 2016 David Lindeque. All rights reserved.
//

#include "smcpp.ds.h"
#include "log.h"
#include "logger.h"

#include <map>
#include <fstream>

namespace dc
{
    inline auto to_cpp_enum(const symbolreference &name) -> std::wstring
    {
        std::wstring s;
        if (name.empty()) return L"";
        s.append(name[0].value());
        for(size_t i = 1; i < name.size(); i++) {
            s.append(L"::");
            s.append(name[i].value());
        }
        return s;
    }

    inline auto get_setting(logger *logger, const std::unordered_map<std::wstring, std::wstring> &settings, const std::wstring &name, bool mandatory, const std::wstring &default_value, bool &ok) -> std::wstring
    {
        auto f = settings.find(name);
        if (f == settings.end()) {
            if (mandatory) {
                log::error::MissingSetting(logger, name);
                ok = false;
                return L"";
            }
            else {
                return default_value;
            }
        }
        else {
            return f->second;
        }
    }
    
    auto smcpp_write(logger *logger, const dfa &dfa, const std::unordered_map<std::wstring, std::wstring> &settings) -> bool
    {
        bool ok = true;
        
        auto cppfn = get_setting(logger, settings, L"cppfn", true, L"", ok);
        auto hfn = get_setting(logger, settings, L"hfn", true, L"", ok);
        auto ns = get_setting(logger, settings, L"namespace", true, L"", ok);
        auto functionName = get_setting(logger, settings, L"functionName", true, L"", ok);
        
        if (!ok) return false;
        
        std::wofstream stm(std::string(cppfn.begin(), cppfn.end()));
        if (!stm) {
            log::error::FailureOpeningFile(logger, nullptr, span(), std::string(cppfn.begin(), cppfn.end()));
            return false;
        }
        stm << L"// Generated by Dave Compiler" << std::endl << std::endl;
        stm << L"#include \"" << hfn << L"\"" << std::endl;
        stm << L"#include <iostream>" << std::endl;
        stm << L"#include <string>" << std::endl;
        stm << std::endl;
        stm << L"namespace " << ns << L" {" << std::endl;
        stm << L"    auto " << functionName << L"(std::wistream &stm, std::vector<size_t> &states, dc::position &p, dc::spantext &value, " << ns << L"::tokentype &token) -> bool" << std::endl;
        stm << L"    {" << std::endl;
        stm << L"        value.spn().begin = p;" << std::endl;
        stm << L"        dc::position last_yield_position;" << std::endl;
        stm << L"        size_t s = states.back();" << std::endl;
        stm << L"        while(true) {" << std::endl;
        stm << L"            auto ch = s.stm.get();" << std::endl;
        stm << L"            if (ch == std::wistream::end()) return false;" << std::endl;
        stm << L"            if (ch == L'\\n') { p.line++; p.column = 1; } else { p.column++; }" << std::endl;
        stm << L"            if (ch == L'\\r') { p.column = 1; }" << std::endl;
        stm << L"            value.value() += (wchar_t)ch" << std::endl;
        stm << L"            switch(s) {" << std::endl;
        for(auto &s : dfa.transitions) {
            stm << L"            case " << s.first << L':' << std::endl;

            auto action = dfa.actions.find(s.first);
            if (action != dfa.actions.end() && action->second.CanYield) {
                stm << L"                last_yield_position = p;" << std::endl;
            }

            stm << L"                switch(ch) {" << std::endl;
            std::vector<const Transition*> ct;
            for(auto &t : s.second) {
                if (t.First == t.Last) {
                    stm << L"                case " << (int)t.First << L": // " << log::printable(t.First) << std::endl;
                    stm << L"                    s = " << t.ToState << L';' << std::endl;
                    stm << L"                    break;" << std::endl;
                }
                else {
                    ct.push_back(&t);
                }
            }
            
            if (!ct.empty() || action != dfa.actions.end()) {
                stm << L"                default:" << std::endl;
                if (!ct.empty()) {
                    stm << L"                    if (ch >= " << (int)ct[0]->First << " && ch <= " << (int)ct[0]->Last << ") { // " << log::printable(ct[0]->First) << L" - " << log::printable(ct[0]->Last) << std::endl;
                    stm << L"                        s = " << ct[0]->ToState << L';' << std::endl;
                    for(size_t i = 1; i < ct.size(); i++) {
                        stm << L"                    } else if (ch >= " << (int)ct[i]->First << " && ch <= " << (int)ct[i]->Last << ") { // " << log::printable(ct[i]->First) << L" - " << log::printable(ct[i]->Last) << std::endl;
                        stm << L"                        value.value() += (wchar_t)ch" << std::endl;
                        stm << L"                        s = " << ct[i]->ToState << L';' << std::endl;
                    }
                    stm << L"                    }" << std::endl;
                    if (action != dfa.actions.end()) {
                        stm << L"                    else {" << std::endl;
                        if (action->second.CanYield) {
                            stm << L"                        // Yield" << std::endl;
                            stm << L"                        value.spn().end = p;" << std::endl;
                            stm << L"                        token = " << ns << L"::" << to_cpp_enum(action->second.YieldAction.TokenName) << L';' << std::endl;
                            if (action->second.YieldAction.IsGoto) {
                                stm << L"                        states.push_back(" << action->second.YieldAction.GotoAutomata << L");" << std::endl;
                            } 
                            else if (action->second.YieldAction.IsReturn) {
                                stm << L"                        states.pop_back();" << std::endl;
                            }
                            stm << L"                        return true;" << std::endl;
                        }
                        //else if (action->second.RewindSteps > 0) {
                        //    stm << L"                        // Rewind" << std::endl;
                        //    stm << L"                        for(int i = 0;i<" << action->second.RewindSteps << L";i++) stm.unget();" << std::endl;
                        //    stm << L"                        p = last_yield_position;" << std::endl;
                        //    stm << L"                        value.value().erase(value.value().begin() + value.value().size() - " << action->second.RewindSteps << L");" << std::endl;
                        //    stm << L"                        value.spn().end = p;" << std::endl;
                        //    stm << L"                        token = " << ns << L"::" << to_cpp_enum(action->second.RewindAction.TokenName) << L';' << std::endl;
                        //    if (action->second.RewindAction.IsGoto) {
                        //        stm << L"                        states.push_back(" << action->second.RewindAction.GotoAutomata << L");" << std::endl;
                        //    }
                        //    else if (action->second.RewindAction.IsReturn) {
                        //        stm << L"                        states.pop_back();" << std::endl;
                        //    }
                        //    stm << L"                        return true;" << std::endl;
                        //}
                        stm << L"                    }" << std::endl;
                    }
                }
                else if (action != dfa.actions.end()) {

                }
                stm << L"                    break;" << std::endl;
            }
            
            stm << L"                }" << std::endl;
            stm << L"                break;" << std::endl;
        }
        stm << L"            }" << std::endl;
        stm << L"        }" << std::endl;
        stm << L"    }" << std::endl;
        stm << L"}" << std::endl;
        
        return true;
    }
}
