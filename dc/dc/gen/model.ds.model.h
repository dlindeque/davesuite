// Generated by Dave Compiler

#pragma once

#include <iostream>
#include <memory>
#include "modelhelpers.h"

namespace dc2 {
    
}
namespace dc {
    enum class TokenType;
}
namespace dc2 {
    class position;
    class span;
    template<typename T> class spanvalue;
    class ast;
    class document_ast;
    class import_ast;
    
}
namespace dc2 {
    
}
namespace dc {
    // Represents the types of tokens in a ds file
    enum class TokenType {
        // Import another file
        Import = 1,
        Set = 2,
        Start = 3,
        Namespace = 4,
        Enum = 5,
        Pattern = 6,
        Automata = 7,
        Include = 8,
        Goto = 9,
        Return = 10,
        Equals = 11,
        String = 12,
        Identifier = 13,
        Number = 14,
        Dot = 15,
        Semicolon = 16,
        Comma = 17,
        Hat = 18,
        Hyphen = 19,
        OpenBrace = 20,
        CloseBrace = 21,
        OpenParenthesis = 22,
        CloseParenthesis = 23,
        OpenSquare = 24,
        CloseSquare = 25,
        OpenTriangle = 26,
        CloseTriangle = 27,
        ProducedBy = 28,
        Comment = 29,
        Whitespace = 30,
        ReStart = 31,
        ReEnd = 32,
        Char = 33,
        CharClass = 34,
        Asterisk = 35,
        Plus = 36,
        Question = 37,
        Pipe = 38,
        // Indicates an error in lexical analysis
        Error = 39,
        EOD = 40,
        Documentation = 41,
        Production = 42,
        Type = 43,
        Abstract = 44,
        Sealed = 45,
        Alias = 46,
        Colon = 47,
        Word = 48,
        DWord = 49,
        Int8 = 50,
        Int16 = 51,
        Int32 = 52,
        Int64 = 53,
        StringKeyword = 54,
        WString = 55,
        FloatKeyword = 56,
        DFloat = 57
    };
    
    inline auto operator <<(std::wostream &os, const TokenType &v) -> std::wostream& {
        switch(v) {
        case TokenType::Import: return os << L"Import";
        case TokenType::Set: return os << L"Set";
        case TokenType::Start: return os << L"Start";
        case TokenType::Namespace: return os << L"Namespace";
        case TokenType::Enum: return os << L"Enum";
        case TokenType::Pattern: return os << L"Pattern";
        case TokenType::Automata: return os << L"Automata";
        case TokenType::Include: return os << L"Include";
        case TokenType::Goto: return os << L"Goto";
        case TokenType::Return: return os << L"Return";
        case TokenType::Equals: return os << L"Equals";
        case TokenType::String: return os << L"String";
        case TokenType::Identifier: return os << L"Identifier";
        case TokenType::Number: return os << L"Number";
        case TokenType::Dot: return os << L"Dot";
        case TokenType::Semicolon: return os << L"Semicolon";
        case TokenType::Comma: return os << L"Comma";
        case TokenType::Hat: return os << L"Hat";
        case TokenType::Hyphen: return os << L"Hyphen";
        case TokenType::OpenBrace: return os << L"OpenBrace";
        case TokenType::CloseBrace: return os << L"CloseBrace";
        case TokenType::OpenParenthesis: return os << L"OpenParenthesis";
        case TokenType::CloseParenthesis: return os << L"CloseParenthesis";
        case TokenType::OpenSquare: return os << L"OpenSquare";
        case TokenType::CloseSquare: return os << L"CloseSquare";
        case TokenType::OpenTriangle: return os << L"OpenTriangle";
        case TokenType::CloseTriangle: return os << L"CloseTriangle";
        case TokenType::ProducedBy: return os << L"ProducedBy";
        case TokenType::Comment: return os << L"Comment";
        case TokenType::Whitespace: return os << L"Whitespace";
        case TokenType::ReStart: return os << L"ReStart";
        case TokenType::ReEnd: return os << L"ReEnd";
        case TokenType::Char: return os << L"Char";
        case TokenType::CharClass: return os << L"CharClass";
        case TokenType::Asterisk: return os << L"Asterisk";
        case TokenType::Plus: return os << L"Plus";
        case TokenType::Question: return os << L"Question";
        case TokenType::Pipe: return os << L"Pipe";
        case TokenType::Error: return os << L"Error";
        case TokenType::EOD: return os << L"EOD";
        case TokenType::Documentation: return os << L"Documentation";
        case TokenType::Production: return os << L"Production";
        case TokenType::Type: return os << L"Type";
        case TokenType::Abstract: return os << L"Abstract";
        case TokenType::Sealed: return os << L"Sealed";
        case TokenType::Alias: return os << L"Alias";
        case TokenType::Colon: return os << L"Colon";
        case TokenType::Word: return os << L"Word";
        case TokenType::DWord: return os << L"DWord";
        case TokenType::Int8: return os << L"Int8";
        case TokenType::Int16: return os << L"Int16";
        case TokenType::Int32: return os << L"Int32";
        case TokenType::Int64: return os << L"Int64";
        case TokenType::StringKeyword: return os << L"StringKeyword";
        case TokenType::WString: return os << L"WString";
        case TokenType::FloatKeyword: return os << L"FloatKeyword";
        case TokenType::DFloat: return os << L"DFloat";
        default: return os << L"(Program Error)";
        }
    }
}
namespace dc2 {
    // Represents a position within a source file/text.
    class position {
    private:
        unsigned long _line;
        unsigned long _column;
    public:
        position()
        {}
        position(const position &c)
        : _line(c._line), _column(c._column)
        {}
        position(position &&c)
        : _line(std::move(c._line)), _column(std::move(c._column))
        {}
        template<typename _Tline, typename _Tcolumn> position(_Tline&& line, _Tcolumn&& column)
        : _line(std::forward<_Tline>(line)), _column(std::forward<_Tcolumn>(column))
        {}
        
        // The line number (First line is 1)
        inline auto line() const -> const unsigned long& { return _line; }
        // The line number (First line is 1)
        template<typename _Value> inline auto set_line(_Value&& value) -> void { _line = std::forward<_Value>(value); }
        // The column number (First column is 1)
        inline auto column() const -> const unsigned long& { return _column; }
        // The column number (First column is 1)
        template<typename _Value> inline auto set_column(_Value&& value) -> void { _column = std::forward<_Value>(value); }
        
        inline auto operator = (const position &c) -> position& {
            _line = c._line;
            _column = c._column;
            return *this;
        }
        inline auto operator = (position &&c) -> position& {
            if (this != &c) {
                _line = std::move(c._line);
                _column = std::move(c._column);
                
            }
            return *this;
        }
        friend inline auto operator == (const position &v1, const position &v2) -> bool {
            return dc::equal(v1, v2);
        }
        friend inline auto operator != (const position &v1, const position &v2) -> bool {
            return !dc::equal(v1, v2);
        }
        friend inline auto operator < (const position &v1, const position &v2) -> bool {
            return dc::compare(v1, v2) < 0;
        }
        friend inline auto operator > (const position &v1, const position &v2) -> bool {
            return dc::compare(v1, v2) > 0;
        }
        friend inline auto operator <= (const position &v1, const position &v2) -> bool {
            return dc::compare(v1, v2) <= 0;
        }
        friend inline auto operator >= (const position &v1, const position &v2) -> bool {
            return dc::compare(v1, v2) >= 0;
        }
        friend inline auto operator << (std::wostream &os, const position &value) -> std::wostream& {
            return dc::standard_writer(os, value);
        }
    };
    // Represents a span of text with a source file/text.
    class span {
    private:
        dc2::position _begin;
        dc2::position _end;
    public:
        span()
        {}
        span(const span &c)
        : _begin(c._begin), _end(c._end)
        {}
        span(span &&c)
        : _begin(std::move(c._begin)), _end(std::move(c._end))
        {}
        template<typename _Tbegin, typename _Tend> span(_Tbegin&& begin, _Tend&& end)
        : _begin(std::forward<_Tbegin>(begin)), _end(std::forward<_Tend>(end))
        {}
        
        // The begin position.
        inline auto begin() const -> const dc2::position& { return _begin; }
        // The begin position.
        template<typename _Value> inline auto set_begin(_Value&& value) -> void { _begin = std::forward<_Value>(value); }
        // The first character beyond the span
        inline auto end() const -> const dc2::position& { return _end; }
        // The first character beyond the span
        template<typename _Value> inline auto set_end(_Value&& value) -> void { _end = std::forward<_Value>(value); }
        
        inline auto operator = (const span &c) -> span& {
            _begin = c._begin;
            _end = c._end;
            return *this;
        }
        inline auto operator = (span &&c) -> span& {
            if (this != &c) {
                _begin = std::move(c._begin);
                _end = std::move(c._end);
                
            }
            return *this;
        }
        friend inline auto operator == (const span &v1, const span &v2) -> bool {
            return dc::equal(v1, v2);
        }
        friend inline auto operator != (const span &v1, const span &v2) -> bool {
            return !dc::equal(v1, v2);
        }
        friend inline auto operator < (const span &v1, const span &v2) -> bool {
            return dc::compare(v1, v2) < 0;
        }
        friend inline auto operator > (const span &v1, const span &v2) -> bool {
            return dc::compare(v1, v2) > 0;
        }
        friend inline auto operator <= (const span &v1, const span &v2) -> bool {
            return dc::compare(v1, v2) <= 0;
        }
        friend inline auto operator >= (const span &v1, const span &v2) -> bool {
            return dc::compare(v1, v2) >= 0;
        }
        friend inline auto operator << (std::wostream &os, const span &value) -> std::wostream& {
            return dc::standard_writer(os, value);
        }
    };
    // A value in a source file
    template<typename T>
    class spanvalue {
    private:
        dc2::span _spn;
        T _value;
    public:
        spanvalue()
        {}
        spanvalue(const spanvalue &c)
        : _spn(c._spn), _value(c._value)
        {}
        spanvalue(spanvalue &&c)
        : _spn(std::move(c._spn)), _value(std::move(c._value))
        {}
        template<typename _Tspn, typename _Tvalue> spanvalue(_Tspn&& spn, _Tvalue&& value)
        : _spn(std::forward<_Tspn>(spn)), _value(std::forward<_Tvalue>(value))
        {}
        
        // The location of the value
        inline auto spn() const -> const dc2::span& { return _spn; }
        // The location of the value
        template<typename _Value> inline auto set_spn(_Value&& value) -> void { _spn = std::forward<_Value>(value); }
        // The value
        inline auto value() const -> const T& { return _value; }
        // The value
        template<typename _Value> inline auto set_value(_Value&& value) -> void { _value = std::forward<_Value>(value); }
        
        inline auto operator = (const spanvalue &c) -> spanvalue& {
            _spn = c._spn;
            _value = c._value;
            return *this;
        }
        inline auto operator = (spanvalue &&c) -> spanvalue& {
            if (this != &c) {
                _spn = std::move(c._spn);
                _value = std::move(c._value);
                
            }
            return *this;
        }
        friend inline auto operator == (const spanvalue &v1, const spanvalue &v2) -> bool {
            return dc::equal(v1, v2);
        }
        friend inline auto operator != (const spanvalue &v1, const spanvalue &v2) -> bool {
            return !dc::equal(v1, v2);
        }
        friend inline auto operator < (const spanvalue &v1, const spanvalue &v2) -> bool {
            return dc::compare(v1, v2) < 0;
        }
        friend inline auto operator > (const spanvalue &v1, const spanvalue &v2) -> bool {
            return dc::compare(v1, v2) > 0;
        }
        friend inline auto operator <= (const spanvalue &v1, const spanvalue &v2) -> bool {
            return dc::compare(v1, v2) <= 0;
        }
        friend inline auto operator >= (const spanvalue &v1, const spanvalue &v2) -> bool {
            return dc::compare(v1, v2) >= 0;
        }
        friend inline auto operator << (std::wostream &os, const spanvalue &value) -> std::wostream& {
            return dc::standard_writer(os, value);
        }
    };
    class ast {
    private:
        dc2::span _spn;
        std::shared_ptr<dc2::ast> _declaring_ast;
    protected:
        ast()
        {}
        ast(const ast &c)
        : _spn(c._spn), _declaring_ast(c._declaring_ast)
        {}
        ast(ast &&c)
        : _spn(std::move(c._spn)), _declaring_ast(std::move(c._declaring_ast))
        {}
        template<typename _Tspn, typename _Tdeclaring_ast> ast(_Tspn&& spn, _Tdeclaring_ast&& declaring_ast)
        : _spn(std::forward<_Tspn>(spn)), _declaring_ast(std::forward<_Tdeclaring_ast>(declaring_ast))
        {}
        
    public:
        
        virtual ~ast() { }
        
        inline auto spn() const -> const dc2::span& { return _spn; }
        template<typename _Value> inline auto set_spn(_Value&& value) -> void { _spn = std::forward<_Value>(value); }
        inline auto declaring_ast() const -> const std::shared_ptr<dc2::ast>& { return _declaring_ast; }
        template<typename _Value> inline auto set_declaring_ast(_Value&& value) -> void { _declaring_ast = std::forward<_Value>(value); }
        
        inline auto operator = (const ast &c) -> ast& {
            _spn = c._spn;
            _declaring_ast = c._declaring_ast;
            return *this;
        }
        inline auto operator = (ast &&c) -> ast& {
            if (this != &c) {
                _spn = std::move(c._spn);
                _declaring_ast = std::move(c._declaring_ast);
                
            }
            return *this;
        }
        friend inline auto operator == (const ast &v1, const ast &v2) -> bool {
            return dc::equal(v1, v2);
        }
        friend inline auto operator != (const ast &v1, const ast &v2) -> bool {
            return !dc::equal(v1, v2);
        }
        friend inline auto operator < (const ast &v1, const ast &v2) -> bool {
            return dc::compare(v1, v2) < 0;
        }
        friend inline auto operator > (const ast &v1, const ast &v2) -> bool {
            return dc::compare(v1, v2) > 0;
        }
        friend inline auto operator <= (const ast &v1, const ast &v2) -> bool {
            return dc::compare(v1, v2) <= 0;
        }
        friend inline auto operator >= (const ast &v1, const ast &v2) -> bool {
            return dc::compare(v1, v2) >= 0;
        }
        friend inline auto operator << (std::wostream &os, const ast &value) -> std::wostream& {
            return dc::standard_writer(os, value);
        }
    };
    // The document ast type
    class document_ast: public dc2::ast {
    private:
        std::wstring _test;
    protected:
        document_ast()
        : ast()
        {}
        document_ast(const document_ast &c)
        : ast(c), _test(c._test)
        {}
        document_ast(document_ast &&c)
        : ast(std::move(c)), _test(std::move(c._test))
        {}
        template<typename _Tspn, typename _Tdeclaring_ast, typename _Ttest> document_ast(_Tspn&& spn, _Tdeclaring_ast&& declaring_ast, _Ttest&& test)
        : ast(std::forward<_Tspn>(spn), std::forward<_Tdeclaring_ast>(declaring_ast)), _test(std::forward<_Ttest>(test))
        {}
        
    public:
        
        virtual ~document_ast() { }
        
        inline auto test() const -> const std::wstring& { return _test; }
        template<typename _Value> inline auto set_test(_Value&& value) -> void { _test = std::forward<_Value>(value); }
        
        inline auto operator = (const document_ast &c) -> document_ast& {
            ((dc2::ast)*this) = c;
            _test = c._test;
            return *this;
        }
        inline auto operator = (document_ast &&c) -> document_ast& {
            if (this != &c) {
                ((dc2::ast)*this) = std::move(c);
                _test = std::move(c._test);
                
            }
            return *this;
        }
        friend inline auto operator == (const document_ast &v1, const document_ast &v2) -> bool {
            return dc::equal(v1, v2);
        }
        friend inline auto operator != (const document_ast &v1, const document_ast &v2) -> bool {
            return !dc::equal(v1, v2);
        }
        friend inline auto operator < (const document_ast &v1, const document_ast &v2) -> bool {
            return dc::compare(v1, v2) < 0;
        }
        friend inline auto operator > (const document_ast &v1, const document_ast &v2) -> bool {
            return dc::compare(v1, v2) > 0;
        }
        friend inline auto operator <= (const document_ast &v1, const document_ast &v2) -> bool {
            return dc::compare(v1, v2) <= 0;
        }
        friend inline auto operator >= (const document_ast &v1, const document_ast &v2) -> bool {
            return dc::compare(v1, v2) >= 0;
        }
        friend inline auto operator << (std::wostream &os, const document_ast &value) -> std::wostream& {
            return dc::standard_writer(os, value);
        }
    };
    class import_ast: public dc2::document_ast {
    private:
        std::wstring _doc;
    public:
        import_ast()
        : document_ast()
        {}
        import_ast(const import_ast &c)
        : document_ast(c), _doc(c._doc)
        {}
        import_ast(import_ast &&c)
        : document_ast(std::move(c)), _doc(std::move(c._doc))
        {}
        template<typename _Tspn, typename _Tdeclaring_ast, typename _Ttest, typename _Tdoc> import_ast(_Tspn&& spn, _Tdeclaring_ast&& declaring_ast, _Ttest&& test, _Tdoc&& doc)
        : document_ast(std::forward<_Tspn>(spn), std::forward<_Tdeclaring_ast>(declaring_ast), std::forward<_Ttest>(test)), _doc(std::forward<_Tdoc>(doc))
        {}
        
        virtual ~import_ast() { }
        
        inline auto doc() const -> const std::wstring& { return _doc; }
        template<typename _Value> inline auto set_doc(_Value&& value) -> void { _doc = std::forward<_Value>(value); }
        
        inline auto operator = (const import_ast &c) -> import_ast& {
            ((dc2::document_ast)*this) = c;
            _doc = c._doc;
            return *this;
        }
        inline auto operator = (import_ast &&c) -> import_ast& {
            if (this != &c) {
                ((dc2::document_ast)*this) = std::move(c);
                _doc = std::move(c._doc);
                
            }
            return *this;
        }
        friend inline auto operator == (const import_ast &v1, const import_ast &v2) -> bool {
            return dc::equal(v1, v2);
        }
        friend inline auto operator != (const import_ast &v1, const import_ast &v2) -> bool {
            return !dc::equal(v1, v2);
        }
        friend inline auto operator < (const import_ast &v1, const import_ast &v2) -> bool {
            return dc::compare(v1, v2) < 0;
        }
        friend inline auto operator > (const import_ast &v1, const import_ast &v2) -> bool {
            return dc::compare(v1, v2) > 0;
        }
        friend inline auto operator <= (const import_ast &v1, const import_ast &v2) -> bool {
            return dc::compare(v1, v2) <= 0;
        }
        friend inline auto operator >= (const import_ast &v1, const import_ast &v2) -> bool {
            return dc::compare(v1, v2) >= 0;
        }
        friend inline auto operator << (std::wostream &os, const import_ast &value) -> std::wostream& {
            return dc::standard_writer(os, value);
        }
    };
    
}
namespace dc {
    template<> struct compare<dc2::import_ast> {
        inline auto operator()(const dc2::import_ast &v1, const dc2::import_ast &v2) const -> int {
            int c = compare<dc2::document_ast>()(v1, v2); if (c != 0) return c;
            c = compare<std::wstring>()(v1.doc(), v2.doc()); if (c != 0) return c;
            return c;
        }
    };
    template<> struct equal<dc2::import_ast> {
        inline auto operator()(const dc2::import_ast &v1, const dc2::import_ast &v2) const -> bool {
            if (!equal<dc2::document_ast>()(v1, v2)) return false;
            if (!equal<std::wstring>()(v1.doc(), v2.doc())) return false;
            return true;
        }
    };
    template<template Arg0> struct compare<dc2::spanvalue<Arg0> > {
        inline auto operator()(const dc2::spanvalue<Arg0>  &v1, const dc2::spanvalue<Arg0>  &v2) const -> int {
            int c = 0;
            c = compare<dc2::span>()(v1.spn(), v2.spn()); if (c != 0) return c;
            c = compare<T>()(v1.value(), v2.value()); if (c != 0) return c;
            return c;
        }
    };
    template<template Arg0> struct equal<dc2::spanvalue<Arg0> > {
        inline auto operator()(const dc2::spanvalue<Arg0>  &v1, const dc2::spanvalue<Arg0>  &v2) const -> bool {
            if (!equal<dc2::span>()(v1.spn(), v2.spn())) return false;
            if (!equal<T>()(v1.value(), v2.value())) return false;
            return true;
        }
    };
    template<> struct compare<dc2::document_ast> {
        inline auto operator()(const dc2::document_ast &v1, const dc2::document_ast &v2) const -> int {
            int c = compare<dc2::ast>()(v1, v2); if (c != 0) return c;
            c = compare<std::wstring>()(v1.test(), v2.test()); if (c != 0) return c;
            return c;
        }
    };
    template<> struct equal<dc2::document_ast> {
        inline auto operator()(const dc2::document_ast &v1, const dc2::document_ast &v2) const -> bool {
            if (!equal<dc2::ast>()(v1, v2)) return false;
            if (!equal<std::wstring>()(v1.test(), v2.test())) return false;
            return true;
        }
    };
    template<> struct compare<dc2::ast> {
        inline auto operator()(const dc2::ast &v1, const dc2::ast &v2) const -> int {
            int c = 0;
            c = compare<dc2::span>()(v1.spn(), v2.spn()); if (c != 0) return c;
            c = compare<dc2::ast>()(v1.declaring_ast(), v2.declaring_ast()); if (c != 0) return c;
            return c;
        }
    };
    template<> struct equal<dc2::ast> {
        inline auto operator()(const dc2::ast &v1, const dc2::ast &v2) const -> bool {
            if (!equal<dc2::span>()(v1.spn(), v2.spn())) return false;
            if (!equal<dc2::ast>()(v1.declaring_ast(), v2.declaring_ast())) return false;
            return true;
        }
    };
    template<> struct compare<dc2::span> {
        inline auto operator()(const dc2::span &v1, const dc2::span &v2) const -> int {
            int c = 0;
            c = compare<dc2::position>()(v1.begin(), v2.begin()); if (c != 0) return c;
            c = compare<dc2::position>()(v1.end(), v2.end()); if (c != 0) return c;
            return c;
        }
    };
    template<> struct equal<dc2::span> {
        inline auto operator()(const dc2::span &v1, const dc2::span &v2) const -> bool {
            if (!equal<dc2::position>()(v1.begin(), v2.begin())) return false;
            if (!equal<dc2::position>()(v1.end(), v2.end())) return false;
            return true;
        }
    };
    template<> struct compare<dc2::position> {
        inline auto operator()(const dc2::position &v1, const dc2::position &v2) const -> int {
            int c = 0;
            c = compare<unsigned long>()(v1.line(), v2.line()); if (c != 0) return c;
            c = compare<unsigned long>()(v1.column(), v2.column()); if (c != 0) return c;
            return c;
        }
    };
    template<> struct equal<dc2::position> {
        inline auto operator()(const dc2::position &v1, const dc2::position &v2) const -> bool {
            if (!equal<unsigned long>()(v1.line(), v2.line())) return false;
            if (!equal<unsigned long>()(v1.column(), v2.column())) return false;
            return true;
        }
    };
    template<typename _Os> struct summary_writer<_Os, dc2::import_ast> {
        inline auto operator()(_Os &os, const dc2::import_ast &value) const -> _Os& {
            return os << "import_ast{..}";
        }
    };
    template<typename _Os> struct standard_writer<_Os, dc2::import_ast> {
        inline auto operator()(_Os &os, const dc2::import_ast &value) const -> _Os& {
            return os << "dc2::import_ast{ doc = " << dc::write_summary(os, doc()) << " }";
        }
    };
    template<typename _Os> struct full_writer<_Os, dc2::import_ast> {
        inline auto operator()(_Os &os, const dc2::import_ast &value) const -> _Os& {
            return os << "dc2::import_ast{ doc = " << dc::write_full(os, doc()) << " }";
        }
    };
    template<typename _Os,typename _Arg0> struct summary_writer<_Os, dc2::spanvalue<Arg0> > {
        inline auto operator()(_Os &os, const dc2::spanvalue<Arg0> &value) const -> _Os& {
            return os << "spanvalue<..>{..}";
        }
    };
    template<typename _Os,typename _Arg0> struct standard_writer<_Os, dc2::spanvalue<Arg0> > {
        inline auto operator()(_Os &os, const dc2::spanvalue<Arg0> &value) const -> _Os& {
            return os << "dc2::spanvalue<..>{ spn = " << dc::write_summary(os, spn()) << " value = " << dc::write_summary(os, value()) << " }";
        }
    };
    template<typename _Os,typename _Arg0> struct full_writer<_Os, dc2::spanvalue<Arg0> > {
        inline auto operator()(_Os &os, const dc2::spanvalue<Arg0> &value) const -> _Os& {
            return os << "dc2::spanvalue<..>{ spn = " << dc::write_full(os, spn()) << " value = " << dc::write_full(os, value()) << " }";
        }
    };
    template<typename _Os> struct summary_writer<_Os, dc2::document_ast> {
        inline auto operator()(_Os &os, const dc2::document_ast &value) const -> _Os& {
            return os << "document_ast{..}";
        }
    };
    template<typename _Os> struct standard_writer<_Os, dc2::document_ast> {
        inline auto operator()(_Os &os, const dc2::document_ast &value) const -> _Os& {
            return os << "dc2::document_ast{ test = " << dc::write_summary(os, test()) << " }";
        }
    };
    template<typename _Os> struct full_writer<_Os, dc2::document_ast> {
        inline auto operator()(_Os &os, const dc2::document_ast &value) const -> _Os& {
            return os << "dc2::document_ast{ test = " << dc::write_full(os, test()) << " }";
        }
    };
    template<typename _Os> struct summary_writer<_Os, dc2::ast> {
        inline auto operator()(_Os &os, const dc2::ast &value) const -> _Os& {
            return os << "ast{..}";
        }
    };
    template<typename _Os> struct standard_writer<_Os, dc2::ast> {
        inline auto operator()(_Os &os, const dc2::ast &value) const -> _Os& {
            return os << "dc2::ast{ spn = " << dc::write_summary(os, spn()) << " declaring_ast = " << dc::write_summary(os, declaring_ast()) << " }";
        }
    };
    template<typename _Os> struct full_writer<_Os, dc2::ast> {
        inline auto operator()(_Os &os, const dc2::ast &value) const -> _Os& {
            return os << "dc2::ast{ spn = " << dc::write_full(os, spn()) << " declaring_ast = " << dc::write_full(os, declaring_ast()) << " }";
        }
    };
    template<typename _Os> struct summary_writer<_Os, dc2::span> {
        inline auto operator()(_Os &os, const dc2::span &value) const -> _Os& {
            return os << "span{..}";
        }
    };
    template<typename _Os> struct standard_writer<_Os, dc2::span> {
        inline auto operator()(_Os &os, const dc2::span &value) const -> _Os& {
            return os << "dc2::span{ begin = " << dc::write_summary(os, begin()) << " end = " << dc::write_summary(os, end()) << " }";
        }
    };
    template<typename _Os> struct full_writer<_Os, dc2::span> {
        inline auto operator()(_Os &os, const dc2::span &value) const -> _Os& {
            return os << "dc2::span{ begin = " << dc::write_full(os, begin()) << " end = " << dc::write_full(os, end()) << " }";
        }
    };
    template<typename _Os> struct summary_writer<_Os, dc2::position> {
        inline auto operator()(_Os &os, const dc2::position &value) const -> _Os& {
            return os << "position{..}";
        }
    };
    template<typename _Os> struct standard_writer<_Os, dc2::position> {
        inline auto operator()(_Os &os, const dc2::position &value) const -> _Os& {
            return os << "dc2::position{ line = " << dc::write_summary(os, line()) << " column = " << dc::write_summary(os, column()) << " }";
        }
    };
    template<typename _Os> struct full_writer<_Os, dc2::position> {
        inline auto operator()(_Os &os, const dc2::position &value) const -> _Os& {
            return os << "dc2::position{ line = " << dc::write_full(os, line()) << " column = " << dc::write_full(os, column()) << " }";
        }
    };
    
}