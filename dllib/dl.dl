/*
    Definition of the dl lexical structure.
*/

import "..\common\common.dl";
import "..\dslib\ds.dl";
import "..\dmlib\dm.dl"

namespace davelexer
{
    using namespace davecommon;

    extend enum davecommon.TokenType
    {
        // Punctuation
        ProducedBy,
    
        // keywords
        Set,
        Initial,
        Pattern,
        Automata,

        // RE
        ReStart,
        ReEnd,
        ReChar,
        ReAsterisk,
        RePlus,
        ReQuestion,
        ReOpenParenthesis,
        ReCloseParenthesis,
        RePipe,
        ReDot,
        ReCharClass,
        ReRangeStart,
        ReRangeEnd,
        ReCardRefStart,
        ReCardRefEnd,
        ReHat,
        ReHyphen,
        ReComma,
        ReCardinality,
        ReIdentifier
    };

    external function char fromHex(string value);
    let fromEscaped value =
        let d = right 1 value
        |: d   :|
        || "n" ||> '\n'
        || "r" ||> '\r'
        ||> char d;

    set valueExpression
    {
        ';' return                  -> token TokenType.Semicolon;
        include davescript.expression;
    };

    set document
    {
        'set'                       -> keyword TokenType.Set;
        'automata'                  -> keyword TokenType.Automata;
        'pattern'                   -> keyword TokenType.Pattern;
        'initial'                   -> keyword TokenType.Initial;

        '\'' goto re                -> token TokenType.ReStart;
        '->' goto valueExpression   -> token TokenType.ProducedBy;

        include davemodel.document;
    };

    initial automata lexer
    {
        include document;
    };

    set reChar
    {
        '\\x{hex}{4}'                             -> value TokenType.ReChar fromHex
        '\\[^xsaAwd]'                             -> value TokenType.ReChar fromEscaped
        '.'                                       -> value TokenType.ReChar char
    };

    /// Process a regular expression section
    automata re
    {
        '\'' return                               -> token TokenType.ReEnd;

        '\*'                                      -> token TokenType.ReAsterisk;
        '\+'                                      -> token TokenType.RePlus;
        '\?'                                      -> token TokenType.ReQuestion;
        '\('                                      -> token TokenType.ReOpenParenthesis;
        '\)'                                      -> token TokenType.ReCloseParentesis;
        '\|'                                      -> token TokenType.RePipe;
        '\.'                                      -> token TokenType.ReDot;
        '\\[saAwd]'                               -> token TokenType.ReCharClass;
        '\[' goto reRange                         -> token TokenType.ReRangeStart;
        '\{' goto reCardRef                       -> token TokenType.ReCardRefStart;

        include reChar;
    };

    /// Process a range inside a regular expression
    /// For instance [a], [a-z], [ab], [ab-d], [^a-z], [a-\-]
    automata reRange
    {
        '\]' return                               -> token TokenType.ReRangeEnd;
        '\^'                                      -> token TokenType.ReHat;
        '-'                                       -> token TokenType.ReHyphen;

        include reChar;
    };

    automata reCardRef
    {
        '\}' return                               -> token TokenType.ReCardRefEnd;
        ','                                       -> token TokenType.ReComma;
        '{integer}'                               -> value TokenType.ReCardinality;
        '{identifier}'                            -> value TokenType.ReIdentifier;
        '\.'                                      -> value TokenType.ReDot;
    };
}